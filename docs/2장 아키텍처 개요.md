## 2.1 네 개의 영역
1. presentation(표현)
    - 사용자의 요청을 해석해서 응용 서비스에 전달한다
    - 응용 서비스의 실행 결과를 사용자가 이해할 수 있는 형식으로 변환하여 응답한다
2. application(응용)
    - 도메인 모델을 이용해서 사용자에게 제공할 기능을 구현한다
    - 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다
3. domain
    - 도메인의 핵심 로직을 구현한다
4. infrastructure
    - 구현 기술에 대한 것을 다룬다
    - 예: RDBMS/MongoDB/Redis 연동, 메시징 큐의 메시지 송수신, STMP를 활용하여 메일 발송 구현

## 2.2 계층 구조 아키텍처
- 상위 계층 -> 하위 계층 의존은 가능하지만, 하위 계층 -> 상위 계층 의존은 불가능하다
- 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다

![image](https://github.com/user-attachments/assets/61cfc541-c2a1-4ddb-8fa7-4355317a7a21)

- 단점: presentation/application/domain 계층이 infrastructure 계층에 종속된다
    - 기능 확장과 테스트에 어려움이 있다

## 2.3 DIP
- 고수준 모듈: 의미 있는 단일 기능을 제공하는 모듈
- 저수준 모듈: 하위 기능을 실제로 구현한 것

- 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다
    - 그런데 고수준 모듈 -> 저수준 모듈로 의존하면 구현 변경과 테스트가 어렵다는 문제가 발생한다

![image](https://github.com/user-attachments/assets/26a11dc2-b91c-4063-9f0a-a80f80f5ecf1)


- ✨DIP는 **추상화한 인터페이스**를 활용하여 **저수준 모듈 -> 고수준 모듈**에 의존하도록 한다
    - DiscountService는 Drools에 의존하는 코드가 없다(= Drools을 이해할 필요가 없다).
    - DroolsRuleDiscounter는 인터페이스를 구현할 뿐이다

![image](https://github.com/user-attachments/assets/7e1d7c2c-d218-465a-95f4-d89d11c4c3d7)


- DIP(의존성 역전 원칙)을 활용하여 기존 문제 해결
    - 기능 확장 어려움 -> 사용할 저수준 모듈을 변경해도 고수준 모듈을 수정할 필요가 없다
    - 테스트 어려움 -> 테스트용 mock 객체를 주입 받아 테스트를 진행한다

- 하위 기능을 추상화한 인터페이스는 고수준 모듈에 위치한다

![image](https://github.com/user-attachments/assets/c35c7219-9108-4552-8b59-74ecbc44312a)


- DIP를 적용하면 응용 영역과 도메인 영역에 영향을 최소화하면서 구현체를 변경하거나 추가할 수 있다

![image](https://github.com/user-attachments/assets/e44625c1-6d41-4a44-a838-ad2bf8a0a1f6)

- DIP를 항상 적용할 필요는 없다. DIP의 이점을 얻는 수준에서 적용범위를 검토해보자
    - 구현 기술에 의존적인 코드를 도메인에 일부 포함하는 게 효과적일 때도 있다
    - 또는 추상화 대상이 잘 떠오르지 않을 때도 있다

## 2.4 도메인 영역의 주요 구성 요소
#### 1. Entity
- 고유의 식별자를 갖는 객체
- 도메인 모델의 데이터를 표현하며 해당 데이터와 관련된 기능을 함께 제공한다
- Order, Member, Product 와 같이 도메인의 고유한 개념을 표현한다

#### 2. Value
- 교유의 식별자를 갖지 않는 객체
- 개념적으로 하나인 값을 표현할 때 사용된다
- 불변으로 구현하는 것을 권장한다 -> 밸류 타입 데이터를 변경할 때 객체 자체를 완전히 교체함을 의미한다
- 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다
- 예: 배송지 주소를 표현하기 위한 Address, 구매 금액을 위한 Money 등

#### 3. Aggregate
- 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것
- 복잡한 도메인 모델을 관리하는 데 도움이 된다
- 예: Order 애그리거트 -> Order 엔티티 + OrderLine 밸류 + Orderer 밸류
- 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고, 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근한다
    - 예: 배송지 정보를 변경할 때는 Order가 구현한 도메인 로직을 항상 따른다
- 애그리거트를 어떻게 구성했느냐에 따라 구현이 복잡해지기도 하고, 트랜잭션 범위가 달라지기도 한다

#### 4. Repository
- 도메인 모델의 영속성을 처리
- 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능
- 예: DBMS 테이블에서 엔티티 객체를 저장하는 기능
- Repository 인터페이스는 domain 영역에 속하며, 실제 구현 클래스는 infrastructure 영역에 속한다

![image](https://github.com/user-attachments/assets/8d764090-13b9-4e21-aab9-b232a02b02f3)

#### 5. Domain Service
- 특정 엔티티에 속하지 않은 도메인 로직
- 도메인 로직이 여러 엔티티와 밸류를 필요로 할 때 도메인 서비스에서 로직을 구현한다
- 예: '할인 금액 계산'은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현한다

## 2.5 요청 처리 흐름
![image](https://github.com/user-attachments/assets/676ca364-17fa-44fe-a922-b36a1951b4b0)

## 2.6 인프라스트럭처 개요
- 다른 영역에서 필요로 하는 프레임워크, 구현 기술, 보조 기능을 지원한다
- DIP를 활용하면 시스템을 더 유연하고 테스트하기 쉽게 만들 수 있다
- 그러나 무조건 인프라스트럭처에 대한 의존을 없앨 필요는 없다
    - 예: `@Table(name = TBL_ORDER)` - JPA의 @Table 을 의도적으로 노출하여, XML 설정을 사용하는 것보다 편리하게 테이블 이름을 지정하도록 했다
    - 예: `@Transactional` - 한 줄로 트랜잭션을 처리할 수 있는데 코드에서 스프링에 대한 의존을 없애려면 복잡한 스프링 설정을 사용해야 한다

## 2.7 모듈 구성
- 정답은 없다. 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 된다

![image](https://github.com/user-attachments/assets/f3a5fa6a-1ab1-4b62-883f-f5aae58c6ce9)